import{M as e,O as t}from"./index-Bs8aadkd.js";import{f as n}from"./dist--YnhsTxm.js";var r=t(e(),1),i=r.useId||(()=>void 0),a=0;function o(e){let[t,o]=r.useState(i());return n(()=>{e||o(e=>e??String(a++))},[e]),e||(t?`radix-${t}`:``)}var s=r.useInsertionEffect||n;function c({prop:e,defaultProp:t,onChange:n=()=>{},caller:i}){let[a,o,s]=l({defaultProp:t,onChange:n}),c=e!==void 0,d=c?e:a;{let t=r.useRef(e!==void 0);r.useEffect(()=>{let e=t.current;if(e!==c){let t=e?`controlled`:`uncontrolled`,n=c?`controlled`:`uncontrolled`;console.warn(`${i} is changing from ${t} to ${n}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`)}t.current=c},[c,i])}let f=r.useCallback(t=>{if(c){let n=u(t)?t(e):t;n!==e&&s.current?.(n)}else o(t)},[c,e,o,s]);return[d,f]}function l({defaultProp:e,onChange:t}){let[n,i]=r.useState(e),a=r.useRef(n),o=r.useRef(t);return s(()=>{o.current=t},[t]),r.useEffect(()=>{a.current!==n&&(o.current?.(n),a.current=n)},[n,a]),[n,i,o]}function u(e){return typeof e==`function`}export{c as b,o as c};